#!/usr/bin/env zsh

IFS=$'\n'

# How often each encountered remote was unsynced ($remotes[bla] == 1 means that
# remote bla was unsynced *once*, not by *one commit*)

typeset -A remotes

# Parse command line arguments

typeset -a hidden

typeset -A depth

typeset -a discover

typeset -A relativeTo

zparseopts\
  a=hidden -hidden=hidden\
  d:=depth -depth:=depth\
  -relative-to:=relativeTo\
  v=verbose -verbose=verbose\
  h=help -help=help

[[ -z $relativeTo ]] && relativeTo=$HOME

function printUsage {
    echo "Usage: chync [OPTION]..."
    column -t -s "|" <<EOF
|-a, --hidden|Whether to include hidden (dot-prefixed) directories if --depth is set [default: ]
|-d, --depth N|If set, check the sync status of the current directory instead of only repositories in .mrconfig with recurse depth N [default: ]
|--relative-to FILE|Output path should be relative to FILE [default: $HOME]
|-v, --verbose|Be verbose
|-h, --help|Print this help
EOF
}

function printConfig {
    echo "--hidden: $hidden"
    echo "--depth: $depth"
    echo "--relative-to: $relativeTo"
    echo "--verbose: $verbose"
    echo "--help: $help"
}

function gitInitialised {
    git status &> /dev/null
    exitCode=$?

    return $exitCode
}

function lastSync {
    remote=$1

    currentBranch=$(git rev-parse --abbrev-ref HEAD 2> /dev/null)
    ref="$remote/synced/$currentBranch"

    last=$(stat -c %y .git/refs/remotes/$ref 2> /dev/null | sed -r "s/\..*$//")
    if [[ $last = "" ]]; then
        last="never"
    fi

    echo "$last"
}

function unsynced {
    remote=$1

    currentBranch=$(git rev-parse --abbrev-ref HEAD 2> /dev/null)
    ref="$remote/synced/$currentBranch"

    # lastSyncedCommit=$(git rev-parse $ref 2> /dev/null)
    git rev-list "HEAD...$ref" --ignore-submodules --count 2> /dev/null
}

function inMrconfig {
    repoPath=$1

    mr run true | grep "^mr run: $(realpath $repoPath)$" &> /dev/null
}

function printRemoteStatus {
    remote=$1

    url=$(git remote get-url $remote)

    syncStatus=""

    num=$(unsynced $remote)
    if [[ $num -gt 0 ]]; then
        # Remember that this remote was unsynced once more
        remotes[$remote]=$(($remotes[$remote] + 1))

        if [[ $num -gt 9 ]]; then
            syncStatus="${syncStatus}+"
        else
            syncStatus="$syncStatus$num"
        fi
    else
        syncStatus="$syncStatus "
    fi

    if [[ $(lastSync $remote) == "never" ]]; then
        syncStatus="${syncStatus}N"
    else
        syncStatus="${syncStatus} "
    fi

    printf "    %3s %s\n" "$syncStatus" "$remote â†’ $url"
}

function printRepositoryStatus {
    repoPath=$1

    repoStatus=""

    if inMrconfig $repoPath; then
        repoStatus="${repoStatus}M"
    # elif shouldBeInMrconfig $remote; then
    #     repoStatus="${repoStatus}!"
    else
        repoStatus="${repoStatus} "
    fi

    pushd $repoPath

    if gitInitialised; then
        unsyncedRemotes=0

        for r in $(git remote); do
            if [[ ! $(unsynced $r) -eq 0 ]]; then
                unsyncedRemotes=$((unsyncedRemotes + 1))
            fi
        done

        # Whether there are uncommitted changes
        if git diff --quiet; then
            repoStatus="${repoStatus}!"
        else
            repoStatus="${repoStatus} "
        fi

        if [[ $unsyncedRemotes -gt 9 ]]; then
            repoStatus="${repoStatus}+"
        else
            repoStatus="${repoStatus}$unsyncedRemotes"
        fi

        printf "%3s %s\n" "$repoStatus" $(relativePath)

        if [[ -n verbose ]]; then
            for r in $(git remote); do
                printRemoteStatus $r
            done
        fi
    else
        printf "%3s %s\n" "$repoStatus" $(relativePath)
    fi

    popd
}


function relativePath {
    realpath --relative-to=$relativeTo $(pwd)
}


function syncStatusRecurse {
    remainingDepth=$1

    # If current directory already under version control
    if gitInitialised; then
        printRepositoryStatus .
    else
        # Search for folders in current directory
        if [[ -n $hidden ]]; then
            dirs=( $(find . -maxdepth 1 -type d) )
        else
            dirs=( $(find . -maxdepth 1 -type d -and -not -name '.*') )
        fi

        for dir in $dirs; do
            pushd "$dir"

            syncStatusRecurse $(($remainingDepth - 1))

            popd
        done
    fi
}


function syncStatus {
    for repo in $(mrControlled); do
        pushd "$repo"

        printRepositoryStatus .

        popd
    done
}


function mrControlled {
    mr run true | sed -r "s/^mr run: (.*)$/\1/" | grep -v "^$" | grep -v "^finished (.* ok)$"
}



[[ -n $verbose ]] && printConfig

[[ -n $help ]] && printUsage && exit 0

if [[ -n $depth ]]; then
    syncStatusRecurse $depth
    exit 0
else
    syncStatus
fi

# unused stuff
# changeDates=( $(find .git/refs/remotes -maxdepth 2 -iname git-annex -printf "%P %A@ " | sed -r "s/\/git-annex//g;s/\.[[:digit:]]*//g") )
# $(git rev-list "HEAD...$r/$currentBranch" --ignore-submodules --count &> /dev/null) -gt 0 ]]
